{"version":3,"file":"index.js","sources":["../../src/utils/getInnerSize.ts","../../src/useEventListener.ts","../../node_modules/style-inject/dist/style-inject.es.js","../../src/Gutter.tsx","../../src/state/reducer.actions.ts","../../src/utils/getGutterSize.ts","../../src/state/reducer.ts","../../src/utils/flattenChildren.ts","../../src/utils/isTouchEvent.ts","../../src/index.tsx"],"sourcesContent":["import { SplitDirection } from '../index';\n\nexport default function getInnerSize(direction: SplitDirection, element: HTMLElement) {\n  // Returns undefined if parent element has no layout yet.\n  // Or if the parent has no size.\n\n  const computedStyle = getComputedStyle(element);\n  if (!computedStyle) return;\n\n  let size = direction === SplitDirection.Horizontal ? element.clientWidth : element.clientHeight;\n\n  if (size === 0) return;\n\n  if (direction === SplitDirection.Horizontal) {\n    size -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  } else {\n    size -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  }\n\n  return size;\n}\n","import { useEffect } from 'react';\n\ninterface UseAddEventListenerOptions extends AddEventListenerOptions {\n  condition: boolean;\n}\n\nfunction useEventListener(event: string, handler: (event: any) => void, deps: any[] = [], useAddEventListenerOptions: UseAddEventListenerOptions = { condition: true }) {\n  const { condition, ...addEventListenerOptions } = useAddEventListenerOptions\n  useEffect(() => {\n    if (condition) {\n      window.addEventListener(event, handler, addEventListenerOptions);\n    }\n    return () => {\n      if (condition) {\n        window.removeEventListener(event, handler)\n      }\n    };\n\n// eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [event, handler, condition, ...deps]);\n}\n\nexport default useEventListener;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React from 'react';\nimport type { MouseEvent, TouchEvent } from 'react';\nimport { SplitDirection, GutterTheme, isTouchDevice } from './index';\n\ninterface GutterProps {\n  className?: string;\n  theme: GutterTheme;\n  draggerClassName?: string;\n  direction?: SplitDirection;\n  onDragging?: (e: MouseEvent | TouchEvent) => void;\n}\n\nconst Gutter = React.forwardRef<HTMLDivElement, GutterProps>((\n  {\n    className,\n    theme,\n    draggerClassName,\n    direction = SplitDirection.Vertical,\n    onDragging,\n  },\n  ref,\n) => {\n  const containerClass = `__dbk__gutter ${direction} ${className || theme}`;\n  const draggerClass = `__dbk__dragger ${direction} ${draggerClassName || theme}`;\n\n  return (\n    <div\n      className={containerClass}\n      ref={ref}\n      dir={direction}\n      onMouseDown={onDragging}\n      onTouchStart={isTouchDevice ? onDragging : undefined}\n    >\n      <div className={draggerClass}/>\n    </div>\n  );\n});\n\nexport default Gutter;\n\n","import type { SplitDirection } from 'index';\n\nexport enum ActionType {\n  SetIsReadyToCompute,\n  CreatePairs,\n  CalculateSizes,\n  StartDragging,\n  StopDragging,\n}\n\nexport interface SetIsReadyToCompute {\n  type: ActionType.SetIsReadyToCompute;\n  payload: {\n    isReady: boolean,\n  };\n}\n\nexport interface CreatePairs {\n  type: ActionType.CreatePairs;\n  payload: {\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n  };\n}\n\nexport interface CalculateSizes {\n  type: ActionType.CalculateSizes;\n  payload: {\n    direction: SplitDirection,\n    gutterIdx: number;\n  };\n}\n\nexport interface StartDragging {\n  type: ActionType.StartDragging;\n  payload: {\n    gutterIdx: number;\n  };\n}\n\ninterface StopDragging {\n  type: ActionType.StopDragging;\n}\n\nexport type Action = SetIsReadyToCompute\n  | CreatePairs\n  | CalculateSizes\n  | StartDragging\n  | StopDragging;\n\n\n","export default function getGutterSizes(gutterSize: number, isFirst: boolean, isLast: boolean) {\n  let aGutterSize: number;\n  let bGutterSize: number;\n\n  if (isFirst) {\n    aGutterSize = gutterSize / 2;\n    bGutterSize = gutterSize;\n  } else if (isLast) {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize / 2;\n  } else {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize;\n  }\n\n  return { aGutterSize, bGutterSize };\n};\n","import { SplitDirection } from '../index';\nimport { Action, ActionType } from './reducer.actions';\nimport Pair from '../pair';\n\nimport getInnerSize from '../utils/getInnerSize';\nimport getGutterSizes from '../utils/getGutterSize';\n\nexport interface State {\n  isReady: boolean;\n\n  isDragging: boolean;\n  draggingIdx?: number; // Index of a gutter that is being dragged.\n\n  pairs: Pair[];\n}\n\nexport default function reducer(state: State, action: Action) {\n  switch (action.type) {\n    case ActionType.SetIsReadyToCompute: {\n      return {\n        ...state,\n        isReady: action.payload.isReady,\n      }\n    }\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    case ActionType.CreatePairs: {\n      const { direction, children, gutters } = action.payload;\n\n      // All children must have common parent.\n      const parent = children[0].parentNode;\n      if (!parent) throw new Error(`Cannot create pairs - parent is undefined.`);\n      const parentSize = getInnerSize(direction, parent as HTMLElement);\n      if (parentSize === undefined) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${parentSize}.`);\n\n      const pairs: Pair[] = [];\n      children.forEach((_, idx) => {\n        if (idx > 0) {\n          const a = children[idx-1];\n          const b = children[idx];\n          const gutter = gutters[idx-1];\n\n          const start = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().left\n            : a.getBoundingClientRect().top;\n\n          const end = direction === SplitDirection.Horizontal\n            ? b.getBoundingClientRect().right\n            : b.getBoundingClientRect().bottom;\n\n          const size = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().width + gutter.getBoundingClientRect().width + b.getBoundingClientRect().width\n            : a.getBoundingClientRect().height + gutter.getBoundingClientRect().height + b.getBoundingClientRect().height\n\n          const gutterSize = direction === SplitDirection.Horizontal\n            ? gutter.getBoundingClientRect().width\n            : gutter.getBoundingClientRect().height;\n\n          const pair: Pair = {\n            idx: idx-1,\n            // TODO: Do we need to have a reference to the whole elements? Aren't indexes enough?\n            a,\n            b,\n            gutter,\n            parent: parent as HTMLElement,\n            start,\n            end,\n            size,\n            gutterSize,\n            // At the start, all elements has the same width.\n            aSizePct: 100 / children.length,\n            bSizePct: 100 / children.length,\n          };\n\n          pairs.push(pair);\n        }\n      });\n\n      return {\n        ...state,\n        pairs,\n      };\n    }\n    case ActionType.StartDragging: {\n      const { gutterIdx } = action.payload;\n      return {\n        ...state,\n        isDragging: true,\n        draggingIdx: gutterIdx,\n      };\n    }\n    case ActionType.StopDragging: {\n      return {\n        ...state,\n        isDragging: false,\n      };\n    }\n    // Recalculates the stored sizes based on the actual elements' sizes.\n    case ActionType.CalculateSizes: {\n      // We need to calculate sizes only for the pair\n      // that has the moved gutter.\n      const { direction, gutterIdx } = action.payload;\n      const pair = state.pairs[gutterIdx];\n\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (!parentSize) throw new Error(`Cannot calculate sizes - 'pair.parent' has undefined or zero size.`);\n\n      const gutterSize = pair.gutter[direction === SplitDirection.Horizontal ? 'clientWidth' : 'clientHeight'];\n\n      const isFirst = gutterIdx === 0;\n      const isLast = gutterIdx === state.pairs.length - 1;\n      const { aGutterSize, bGutterSize } = getGutterSizes(gutterSize, isFirst, isLast);\n\n      let start: number;\n      let end: number;\n      let size: number;\n      let aSizePct: number;\n      let bSizePct: number;\n\n      if (direction === SplitDirection.Horizontal) {\n        start = pair.a.getBoundingClientRect().left;\n\n        end = pair.b.getBoundingClientRect().right;\n\n        aSizePct = ((pair.a.getBoundingClientRect().width + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().width + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().width +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().width;\n      } else {\n        start = pair.a.getBoundingClientRect().top;\n\n        end = pair.b.getBoundingClientRect().bottom;\n\n        aSizePct = ((pair.a.getBoundingClientRect().height + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().height + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().height +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().height;\n      }\n\n      state.pairs[gutterIdx] = {\n        ...pair,\n        start,\n        end,\n        size,\n        aSizePct,\n        bSizePct,\n        gutterSize,\n      };\n\n      return {\n        ...state\n      };\n    }\n    default:\n      return state;\n  }\n}\n\n","// Taken from https://github.com/grrowl/react-keyed-flatten-children\n\n/* Returns React children into an array, flattening fragments. */\nimport {\n  ReactNode,\n  ReactChild,\n  Children,\n  isValidElement,\n  cloneElement\n} from 'react';\nimport { isFragment } from 'react-is';\n\nexport default function flattenChildren(\n  children: ReactNode,\n  depth: number = 0,\n  keys: (string | number)[] = []\n): ReactChild[] {\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) => {\n      if (isFragment(node)) {\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (typeof node === 'string' || typeof node === 'number') {\n          acc.push(node);\n        }\n      }\n      return acc;\n    },\n    []\n  );\n}\n","import type { MouseEvent, TouchEvent } from 'react';\n\nexport const isTouchEvent = (e: MouseEvent | TouchEvent): e is TouchEvent => {\n  return 'changedTouches' in e\n}\n","import React, {\n  useEffect,\n  useReducer,\n  useRef,\n} from 'react';\nimport type { MouseEvent, TouchEvent } from 'react';\n\nimport './index.css';\nimport getInnerSize from './utils/getInnerSize';\nimport useEventListener from './useEventListener';\nimport Gutter from './Gutter';\nimport { ActionType } from './state/reducer.actions';\nimport reducer, { State } from './state/reducer';\nimport getGutterSizes from './utils/getGutterSize';\nimport flattenChildren from './utils/flattenChildren';\nimport { isTouchEvent } from 'utils/isTouchEvent';\n\nexport enum SplitDirection {\n  Horizontal = 'Horizontal',\n  Vertical = 'Vertical',\n}\n\nexport enum GutterTheme {\n  Light = 'Light',\n  Dark = 'Dark',\n}\n\nconst DefaultMinSize = 16;\n\nexport const isTouchDevice = typeof window !== 'undefined' && 'ontouchstart' in window;\n\n// users touch or mouse position\nfunction getPosition(dir: SplitDirection, e: MouseEvent | TouchEvent) {\n  const targetsValueRef = isTouchEvent(e) ? e.changedTouches[0] : e;\n  if (dir === SplitDirection.Horizontal) return targetsValueRef.clientX;\n  return targetsValueRef.clientY;\n}\n\nfunction getCursorIcon(dir: SplitDirection) {\n  if (dir === SplitDirection.Horizontal) return 'col-resize';\n  return 'row-resize';\n}\n\n/*\nconst stateInit: State = (direction: SplitDirection = SplitDirection.Horizontal) => ({\n  direction,\n  isDragging: false,\n  pairs: [],\n});\n*/\n\nconst initialState: State = {\n  isReady: false,\n  isDragging: false,\n  pairs: [],\n}\n\ninterface SplitProps {\n  direction?: SplitDirection;\n  minWidths?: number[]; // In pixels.\n  minHeights?: number[]; // In pixels.\n  initialSizes?: number[]; // In percentage.\n  gutterTheme?: GutterTheme;\n  gutterClassName?: string;\n  draggerClassName?: string;\n  children?: React.ReactNode;\n  onResizeStarted?: (pairIdx: number) => void;\n  onResizeFinished?: (pairIdx: number, newSizes: number[]) => void;\n  classes?: string[];\n}\n\nfunction Split({\n  direction = SplitDirection.Horizontal,\n  minWidths = [],\n  minHeights = [],\n  initialSizes,\n  gutterTheme = GutterTheme.Dark,\n  gutterClassName,\n  draggerClassName,\n  children: reactChildren,\n  onResizeStarted,\n  onResizeFinished,\n  classes = [],\n}: SplitProps) {\n  const children = flattenChildren(reactChildren)\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const containerRef = useRef<HTMLDivElement>(null)\n  const childRefs = useRef<HTMLElement[]>([]);\n  const gutterRefs = useRef<HTMLElement[]>([]);\n  // We want to reset refs on each re-render so they don't contain old references.\n  childRefs.current = [];\n  gutterRefs.current = [];\n\n  // Helper dispatch functions.\n  const setIsReadyToCompute = React.useCallback((isReady: boolean) => {\n    dispatch({\n      type: ActionType.SetIsReadyToCompute,\n      payload: { isReady },\n    })\n  }, [])\n\n  const startDragging = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.StartDragging,\n      payload: { gutterIdx },\n    });\n\n    const pair = state.pairs[gutterIdx];\n    onResizeStarted?.(pair.idx)\n\n    // Disable selection.\n    pair.a.style.userSelect = 'none';\n    pair.b.style.userSelect = 'none';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, nut just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = getCursorIcon(direction);\n    pair.parent.style.cursor = getCursorIcon(direction);\n    document.body.style.cursor = getCursorIcon(direction);\n  }, [state.pairs]);\n\n  const stopDragging = React.useCallback(() => {\n    dispatch({\n      type: ActionType.StopDragging,\n    });\n\n    // The callback receives an index of the resized pair and new sizes of all child elements.\n    const allSizes: number[] = [];\n    for (let idx = 0; idx < state.pairs.length; idx++) {\n      const pair = state.pairs[idx];\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (parentSize === undefined) throw new Error(`Cannot call the 'onResizeFinished' callback - parentSize is undefined`);\n      if (pair.gutterSize === undefined) throw new Error(`Cannot call 'onResizeFinished' callback - gutterSize is undefined`);\n\n      const isFirst = idx === 0;\n      const isLast = idx === state.pairs.length - 1;\n\n      const aSize = pair.a.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n      const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n      const aSizePct = ((aSize + aGutterSize) / parentSize) * 100;\n      allSizes.push(aSizePct);\n\n      if (isLast) {\n        const bSize = pair.b.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        const bSizePct = ((bSize + bGutterSize) / parentSize) * 100;\n        allSizes.push(bSizePct);\n      }\n    }\n\n    if (state.draggingIdx === undefined) throw new Error(`Could not reset cursor and user-select because 'state.draggingIdx' is undefined`);\n    const pair = state.pairs[state.draggingIdx];\n    onResizeFinished?.(pair.idx, allSizes);\n\n    // Disable selection.\n    pair.a.style.userSelect = '';\n    pair.b.style.userSelect = '';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, not just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = '';\n    pair.parent.style.cursor = '';\n    document.body.style.cursor = '';\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const calculateSizes = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.CalculateSizes,\n      payload: { direction, gutterIdx },\n    });\n  }, []);\n\n  const createPairs = React.useCallback((direction: SplitDirection, children: HTMLElement[], gutters: HTMLElement[]) => {\n    dispatch({\n      type: ActionType.CreatePairs,\n      payload: { direction, children, gutters },\n    });\n  }, []);\n  /////////\n\n  // This method is called on the initial render.\n  // It iterates through the all children sets their initial sizes.\n  const setInitialSizes = React.useCallback((\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n    initialSizes?: number[],\n  ) => {\n    // All children must have common parent.\n    const parent = children[0].parentNode;\n    if (!parent) throw new Error(`Cannot set initial sizes - parent is undefined`);\n    const parentSize = getInnerSize(direction, parent as HTMLElement);\n    if (parentSize === undefined) throw new Error(`Cannot set initial sizes - parent has undefined size`);\n\n    children.forEach((c, idx) => {\n      const isFirst = idx === 0;\n      const isLast = idx === children.length - 1;\n\n      let gutterSize = 0\n      if (children.length > 1) {\n        const gutter = gutters[isLast ? idx-1 : idx];\n        let gutterSize = gutter.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        gutterSize = isFirst || isLast ? gutterSize / 2 : gutterSize;\n      }\n\n      let calc: string;\n      if (initialSizes && idx < initialSizes.length)  {\n        calc = `calc(${initialSizes[idx]}% - ${gutterSize}px)`;\n      } else {\n        // '100 / children.length' makes all the children same wide.\n        calc = `calc(${100 / children.length}% - ${gutterSize}px)`;\n      }\n\n      if (direction === SplitDirection.Horizontal) {\n        c.style.width = calc;\n        // Reset the child wrapper's height because the direction could have changed.\n        c.style.height = '100%';\n      } else {\n        c.style.height = calc;\n        // Reset the child wrapper's width because the direction could have changed.\n        c.style.width = '100%';\n      }\n    });\n  }, []);\n\n  // Here we actually change the width of children.\n  // We convert the element's sizes into percentage\n  // and let the CSS 'calc' function do the heavy lifting.\n  // Size of 'pair.a' is same as 'offset'.\n  //\n  // For just 2 children total, the percentage adds up always to 100.\n  // For >2 children total, the percentage adds to less than 100.\n  // That's because a single gutter changes sizes of only the given pair of children.\n  // Each gutter changes size only of the two adjacent elements.\n  // -----------------------------------------------------------------------\n  // |                     |||                     |||                     |\n  // |       33.3%         |||        33.3%        |||       33.3%         |\n  // |                     |||                     |||                     |\n  // |                     |||                     |||                     |\n  // -----------------------------------------------------------------------\n  const adjustSize = React.useCallback((direction: SplitDirection, offset: number) => {\n    if (state.draggingIdx === undefined) throw new Error(`Cannot adjust size - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.size === undefined) throw new Error(`Cannot adjust size - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot adjust size - 'pair.gutterSize' is undefined`);\n    const percentage = pair.aSizePct + pair.bSizePct;\n\n    const aSizePct = (offset / pair.size) * percentage;\n    const bSizePct = percentage - (offset / pair.size) * percentage;\n\n    const isFirst = state.draggingIdx === 0;\n    const isLast = state.draggingIdx === state.pairs.length - 1;\n    const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n\n    const aCalc = `calc(${aSizePct}% - ${aGutterSize}px)`;\n    const bCalc = `calc(${bSizePct}% - ${bGutterSize}px)`;\n    if (direction === SplitDirection.Horizontal) {\n      pair.a.style.width = aCalc;\n      pair.b.style.width = bCalc;\n    } else {\n      pair.a.style.height = aCalc;\n      pair.b.style.height = bCalc;\n    }\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const drag = React.useCallback((e: MouseEvent | TouchEvent, direction: SplitDirection, minSizes: number[]) => {\n    if (!state.isDragging) return\n    if (state.draggingIdx === undefined) throw new Error(`Cannot drag - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.start === undefined) throw new Error(`Cannot drag - 'pair.start' is undefined`);\n    if (pair.size === undefined) throw new Error(`Cannot drag - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot drag - 'pair.gutterSize' is undefined`);\n\n    // 'offset' is the width of the 'a' element in a pair.\n    let offset = getPosition(direction, e) - pair.start;\n\n    // Limit the maximum size and the minimum size of resized children.\n\n    let aMinSize = DefaultMinSize;\n    let bMinSize = DefaultMinSize;\n    if (minSizes.length > state.draggingIdx) {\n      aMinSize = minSizes[state.draggingIdx];\n    }\n    if (minSizes.length >= state.draggingIdx + 1) {\n      bMinSize = minSizes[state.draggingIdx + 1];\n    }\n\n    // TODO: We should check whether the parent is big enough\n    // to support these min sizes.\n    if (offset < pair.gutterSize + aMinSize) {\n      offset = pair.gutterSize + aMinSize;\n    }\n\n    if (offset >= pair.size - (pair.gutterSize + bMinSize)) {\n      offset = pair.size - (pair.gutterSize + bMinSize);\n    }\n\n    adjustSize(direction, offset);\n  }, [state.isDragging, state.draggingIdx, state.pairs, adjustSize]);\n\n  function handleStartDragging(gutterIdx: number) {\n    calculateSizes(direction, gutterIdx);\n    startDragging(direction, gutterIdx);\n  }\n\n  const onStopDragging = () => {\n    if (!state.isDragging) return;\n    if (state.draggingIdx === undefined)\n      throw new Error(`Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined`);\n    calculateSizes(direction, state.draggingIdx);\n    stopDragging();\n  };\n\n  const onMove = (e: MouseEvent | TouchEvent) => {\n    if (!state.isDragging) return;\n    if (isTouchEvent(e)) {\n      // touch event also scrolls the page, so we need to prevent that\n      e.preventDefault();\n    }\n    drag(e, direction, direction === SplitDirection.Horizontal ? minWidths : minHeights);\n  };\n\n  useEventListener(\"mouseup\", onStopDragging, [state.isDragging, stopDragging]);\n  useEventListener(\"mousemove\", onMove, [direction, state.isDragging, drag, minWidths, minHeights]);\n\n  useEventListener(\"touchend\", onStopDragging, [state.isDragging, stopDragging], { condition: isTouchDevice });\n  useEventListener(\"touchmove\", onMove, [direction, state.isDragging, drag, minWidths, minHeights], { condition: isTouchDevice, passive: !isTouchDevice });\n\n  // This makes sure that Splitter properly re-renders if parent's size changes dynamically.\n  useEffect(function watchParentSize() {\n    if (!containerRef.current) return\n    const el = containerRef.current.parentElement\n\n    // Splitter must have a parent element. In the most trivial example it's either <body> or <html>.\n    if (!el) return\n\n    // TODO: Potential performance issue!\n    // When nesting Splitters the `observer` is registered for each nesting \"level\".\n    // Splitter's parent element is another Splitter in the nesting use case.\n    const observer = new ResizeObserver(() => {\n      const style = getComputedStyle(el)\n      const size = direction === SplitDirection.Horizontal ? el.clientWidth : el.clientHeight\n      const isReady = !!style && !!size\n      setIsReadyToCompute(isReady)\n    })\n    observer.observe(el)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [\n    containerRef.current,\n    direction,\n  ])\n\n  // Initial setup, runs every time the child views change.\n  useEffect(function initialSetup() {\n    if (!state.isReady) return\n    // By the time first useEffect runs refs should be already set, unless something really bad happened.\n    if (!childRefs.current || !gutterRefs.current) {\n      throw new Error(`Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined`);\n    }\n\n    // Don't create pairs if there's only one child.\n    if (children.length <= 1) {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n    } else {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n      createPairs(direction, childRefs.current, gutterRefs.current);\n    }\n\n  }, [\n    reactChildren,\n    state.isReady,\n    direction,\n    setInitialSizes,\n    createPairs,\n    initialSizes,\n  ]);\n\n  function addRef(refs: typeof childRefs | typeof gutterRefs, el: any) {\n    if (!refs.current) throw new Error(`Can't add element to ref object - ref isn't initialized`);\n    if (el && !refs.current.includes(el)) {\n      refs.current.push(el);\n    }\n  }\n\n  return (\n    <div\n      className={'__dbk__container ' + `${direction}`}\n      ref={containerRef}\n    >\n      {state.isReady && children.map((c, idx) => (\n        <React.Fragment key={idx}>\n          <div\n            ref={el => addRef(childRefs, el)}\n            className={'__dbk__child-wrapper ' + (idx < classes.length ? classes[idx] : '')}\n          >{c}\n          </div>\n\n          {/* Gutter is between each two child views. */}\n          {idx < (children as React.ReactNodeArray).length - 1 &&\n            <Gutter\n              ref={el => addRef(gutterRefs, el)}\n              className={gutterClassName}\n              theme={gutterTheme}\n              draggerClassName={draggerClassName}\n              direction={direction}\n              onDragging={() => handleStartDragging(idx)}\n            />\n          }\n        </React.Fragment>\n      ))}\n    </div>\n  );\n}\n\nexport type {\n  SplitProps\n}\nexport default Split;\n"],"names":["getInnerSize","direction","element","computedStyle","getComputedStyle","size","SplitDirection","Horizontal","clientWidth","clientHeight","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","useEventListener","event","handler","deps","useAddEventListenerOptions","condition","addEventListenerOptions","useEffect","window","addEventListener","removeEventListener","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","Gutter","React","forwardRef","className","theme","draggerClassName","Vertical","onDragging","containerClass","draggerClass","_jsx","dir","onMouseDown","onTouchStart","isTouchDevice","undefined","ActionType","getGutterSizes","gutterSize","isFirst","isLast","aGutterSize","bGutterSize","reducer","state","action","SetIsReadyToCompute","isReady","payload","CreatePairs","children","gutters","parent","parentNode","Error","parentSize","pairs","forEach","_","idx","a","b","gutter","start","getBoundingClientRect","left","top","end","right","bottom","width","height","pair","aSizePct","length","bSizePct","push","StartDragging","gutterIdx","isDragging","draggingIdx","StopDragging","CalculateSizes","flattenChildren","depth","keys","Children","toArray","reduce","acc","node","nodeIndex","isFragment","apply","props","concat","key","isValidElement","cloneElement","String","join","isTouchEvent","e","GutterTheme","getCursorIcon","initialState","Split","minWidths","minHeights","initialSizes","gutterTheme","Dark","gutterClassName","reactChildren","onResizeStarted","onResizeFinished","classes","dispatch","useReducer","containerRef","useRef","childRefs","gutterRefs","current","setIsReadyToCompute","useCallback","startDragging","userSelect","cursor","body","stopDragging","allSizes","aSize","calculateSizes","createPairs","setInitialSizes","c","calc","adjustSize","offset","percentage","aCalc","bCalc","drag","minSizes","targetsValueRef","changedTouches","clientX","clientY","getPosition","aMinSize","bMinSize","onStopDragging","onMove","preventDefault","addRef","refs","el","includes","passive","parentElement","observer","ResizeObserver","observe","disconnect","map","_jsxs","Fragment","handleStartDragging"],"mappings":"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"}