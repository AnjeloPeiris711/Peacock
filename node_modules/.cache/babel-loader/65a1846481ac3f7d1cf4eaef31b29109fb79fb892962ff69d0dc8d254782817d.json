{"ast":null,"code":"import { jsx as e, jsxs as t } from \"react/jsx-runtime\";\nimport n, { useEffect as i, Children as r, isValidElement as a, cloneElement as o, useReducer as g, useRef as d } from \"react\";\nimport { isFragment as s } from \"react-is\";\n\nfunction c(e, t) {\n  const n = getComputedStyle(t);\n  if (!n) return;\n  let i = e === p.Horizontal ? t.clientWidth : t.clientHeight;\n  return 0 !== i ? (e === p.Horizontal ? i -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight) : i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), i) : void 0;\n}\n\nfunction l(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  i(() => (window.addEventListener(e, t), () => window.removeEventListener(e, t)), [e, t, ...n]);\n}\n\n!function (e, t) {\n  void 0 === t && (t = {});\n  var n = t.insertAt;\n\n  if (e && \"undefined\" != typeof document) {\n    var i = document.head || document.getElementsByTagName(\"head\")[0],\n        r = document.createElement(\"style\");\n    r.type = \"text/css\", \"top\" === n && i.firstChild ? i.insertBefore(r, i.firstChild) : i.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e));\n  }\n}(\"/* === Main Container === */\\n.__dbk__container {\\n  height: 100%;\\n  width: 100%;\\n\\n  display: flex;\\n  overflow: hidden;\\n}\\n\\n.__dbk__container.Horizontal {\\n  flex-direction: row;\\n}\\n\\n.__dbk__container.Vertical {\\n  flex-direction: column;\\n}\\n/* ====== */\\n\\n/* === Wrapper for each child element === */\\n.__dbk__child-wrapper {\\n  height: 100%;\\n  width: 100%;\\n}\\n/* ====== */\\n\\n/* === Gutter === */\\n.__dbk__gutter {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n/* .__dbk__gutter > div {\\n  background: red;\\n} */\\n.__dbk__gutter.Horizontal {\\n  height: 100%;\\n  padding: 0 2px;\\n  flex-direction: column;\\n}\\n.__dbk__gutter.Horizontal:hover {\\n  cursor: col-resize;\\n}\\n\\n.__dbk__gutter.Vertical {\\n  width: 100%;\\n  padding: 2px 0;\\n  flex-direction: row;\\n}\\n.__dbk__gutter.Vertical:hover {\\n  cursor: row-resize;\\n}\\n\\n.__dbk__gutter.Light {\\n  background: #EDF0EF;\\n}\\n.__dbk__gutter.Light:hover > .__dbk__dragger {\\n  background: #76747B;\\n}\\n\\n.__dbk__gutter.Dark {\\n  background: #020203;\\n}\\n.__dbk__gutter.Dark:hover > .__dbk__dragger {\\n  background: #9995A3;\\n}\\n/* ====== */\\n\\n/* === Gutter's Dragger === */\\n.__dbk__dragger {\\n  border-radius: 2px;\\n}\\n\\n.__dbk__dragger.Horizontal {\\n  width: 4px;\\n  height: 24px;  \\n}\\n\\n.__dbk__dragger.Vertical {\\n  width: 24px;\\n  height: 4px;  \\n}\\n\\n.__dbk__dragger.Light {\\n  background: #A6ACB5;\\n}\\n\\n.__dbk__dragger.Dark {\\n  background: #434252;\\n}\\n/* ====== */\");\nconst u = n.forwardRef((_ref, o) => {\n  let {\n    className: t,\n    theme: n,\n    draggerClassName: i,\n    direction: r = p.Vertical,\n    onMouseDown: a\n  } = _ref;\n  const g = `__dbk__gutter ${r} ${t || n}`,\n        d = `__dbk__dragger ${r} ${i || n}`;\n  return e(\"div\", Object.assign({\n    className: g,\n    ref: o,\n    dir: r,\n    onMouseDown: a\n  }, {\n    children: e(\"div\", {\n      className: d\n    }, void 0)\n  }), void 0);\n});\nvar h, p, f;\n\nfunction _(e, t, n) {\n  let i, r;\n  return t ? (i = e / 2, r = e) : n ? (i = e, r = e / 2) : (i = e, r = e), {\n    aGutterSize: i,\n    bGutterSize: r\n  };\n}\n\nfunction z(e, t) {\n  switch (t.type) {\n    case h.SetIsReadyToCompute:\n      return Object.assign(Object.assign({}, e), {\n        isReady: t.payload.isReady\n      });\n\n    case h.CreatePairs:\n      {\n        const {\n          direction: n,\n          children: i,\n          gutters: r\n        } = t.payload,\n              a = i[0].parentNode;\n        if (!a) throw new Error(\"Cannot create pairs - parent is undefined.\");\n        const o = c(n, a);\n        if (void 0 === o) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${o}.`);\n        const g = [];\n        return i.forEach((e, t) => {\n          if (t > 0) {\n            const e = i[t - 1],\n                  o = i[t],\n                  d = r[t - 1],\n                  s = n === p.Horizontal ? e.getBoundingClientRect().left : e.getBoundingClientRect().top,\n                  c = n === p.Horizontal ? o.getBoundingClientRect().right : o.getBoundingClientRect().bottom,\n                  l = n === p.Horizontal ? e.getBoundingClientRect().width + d.getBoundingClientRect().width + o.getBoundingClientRect().width : e.getBoundingClientRect().height + d.getBoundingClientRect().height + o.getBoundingClientRect().height,\n                  u = n === p.Horizontal ? d.getBoundingClientRect().width : d.getBoundingClientRect().height,\n                  h = {\n              idx: t - 1,\n              a: e,\n              b: o,\n              gutter: d,\n              parent: a,\n              start: s,\n              end: c,\n              size: l,\n              gutterSize: u,\n              aSizePct: 100 / i.length,\n              bSizePct: 100 / i.length\n            };\n            g.push(h);\n          }\n        }), Object.assign(Object.assign({}, e), {\n          pairs: g\n        });\n      }\n\n    case h.StartDragging:\n      {\n        const {\n          gutterIdx: n\n        } = t.payload;\n        return Object.assign(Object.assign({}, e), {\n          isDragging: !0,\n          draggingIdx: n\n        });\n      }\n\n    case h.StopDragging:\n      return Object.assign(Object.assign({}, e), {\n        isDragging: !1\n      });\n\n    case h.CalculateSizes:\n      {\n        const {\n          direction: n,\n          gutterIdx: i\n        } = t.payload,\n              r = e.pairs[i],\n              a = c(n, r.parent);\n        if (!a) throw new Error(\"Cannot calculate sizes - 'pair.parent' has undefined or zero size.\");\n\n        const o = r.gutter[n === p.Horizontal ? \"clientWidth\" : \"clientHeight\"],\n              g = 0 === i,\n              d = i === e.pairs.length - 1,\n              {\n          aGutterSize: s,\n          bGutterSize: l\n        } = _(o, g, d);\n\n        let u, h, f, z, b;\n        return n === p.Horizontal ? (u = r.a.getBoundingClientRect().left, h = r.b.getBoundingClientRect().right, z = (r.a.getBoundingClientRect().width + s) / a * 100, b = (r.b.getBoundingClientRect().width + l) / a * 100, f = r.a.getBoundingClientRect().width + s + l + r.b.getBoundingClientRect().width) : (u = r.a.getBoundingClientRect().top, h = r.b.getBoundingClientRect().bottom, z = (r.a.getBoundingClientRect().height + s) / a * 100, b = (r.b.getBoundingClientRect().height + l) / a * 100, f = r.a.getBoundingClientRect().height + s + l + r.b.getBoundingClientRect().height), e.pairs[i] = Object.assign(Object.assign({}, r), {\n          start: u,\n          end: h,\n          size: f,\n          aSizePct: z,\n          bSizePct: b,\n          gutterSize: o\n        }), Object.assign({}, e);\n      }\n\n    default:\n      return e;\n  }\n}\n\nfunction b(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return r.toArray(e).reduce((e, i, r) => (s(i) ? e.push.apply(e, b(i.props.children, t + 1, n.concat(i.key || r))) : a(i) ? e.push(o(i, {\n    key: n.concat(String(i.key)).join(\".\")\n  })) : \"string\" != typeof i && \"number\" != typeof i || e.push(i), e), []);\n}\n\n!function (e) {\n  e[e.SetIsReadyToCompute = 0] = \"SetIsReadyToCompute\", e[e.CreatePairs = 1] = \"CreatePairs\", e[e.CalculateSizes = 2] = \"CalculateSizes\", e[e.StartDragging = 3] = \"StartDragging\", e[e.StopDragging = 4] = \"StopDragging\";\n}(h || (h = {})), function (e) {\n  e.Horizontal = \"Horizontal\", e.Vertical = \"Vertical\";\n}(p || (p = {})), function (e) {\n  e.Light = \"Light\", e.Dark = \"Dark\";\n}(f || (f = {}));\n\nfunction C(e) {\n  return e === p.Horizontal ? \"col-resize\" : \"row-resize\";\n}\n\nconst w = {\n  isReady: !1,\n  isDragging: !1,\n  pairs: []\n};\n\nfunction y(_ref2) {\n  let {\n    direction: r = p.Horizontal,\n    minWidths: a = [],\n    minHeights: o = [],\n    initialSizes: s,\n    gutterTheme: y = f.Dark,\n    gutterClassName: S,\n    draggerClassName: m,\n    children: k,\n    onResizeStarted: x,\n    onResizeFinished: R,\n    classes: v = []\n  } = _ref2;\n  const B = b(k),\n        [I, D] = g(z, w),\n        H = d(null),\n        E = d([]),\n        j = d([]);\n  E.current = [], j.current = [];\n  const O = n.useCallback(e => {\n    D({\n      type: h.SetIsReadyToCompute,\n      payload: {\n        isReady: e\n      }\n    });\n  }, []),\n        N = n.useCallback((e, t) => {\n    D({\n      type: h.StartDragging,\n      payload: {\n        gutterIdx: t\n      }\n    });\n    const n = I.pairs[t];\n    null == x || x(n.idx), n.a.style.userSelect = \"none\", n.b.style.userSelect = \"none\", n.gutter.style.cursor = C(e), n.parent.style.cursor = C(e), document.body.style.cursor = C(e);\n  }, [I.pairs]),\n        $ = n.useCallback(() => {\n    D({\n      type: h.StopDragging\n    });\n    const e = [];\n\n    for (let t = 0; t < I.pairs.length; t++) {\n      const n = I.pairs[t],\n            i = c(r, n.parent);\n      if (void 0 === i) throw new Error(\"Cannot call the 'onResizeFinished' callback - parentSize is undefined\");\n      if (void 0 === n.gutterSize) throw new Error(\"Cannot call 'onResizeFinished' callback - gutterSize is undefined\");\n\n      const a = 0 === t,\n            o = t === I.pairs.length - 1,\n            g = n.a.getBoundingClientRect()[r === p.Horizontal ? \"width\" : \"height\"],\n            {\n        aGutterSize: d,\n        bGutterSize: s\n      } = _(n.gutterSize, a, o),\n            l = (g + d) / i * 100;\n\n      if (e.push(l), o) {\n        const t = (n.b.getBoundingClientRect()[r === p.Horizontal ? \"width\" : \"height\"] + s) / i * 100;\n        e.push(t);\n      }\n    }\n\n    if (void 0 === I.draggingIdx) throw new Error(\"Could not reset cursor and user-select because 'state.draggingIdx' is undefined\");\n    const t = I.pairs[I.draggingIdx];\n    null == R || R(t.idx, e), t.a.style.userSelect = \"\", t.b.style.userSelect = \"\", t.gutter.style.cursor = \"\", t.parent.style.cursor = \"\", document.body.style.cursor = \"\";\n  }, [I.draggingIdx, I.pairs, r]),\n        F = n.useCallback((e, t) => {\n    D({\n      type: h.CalculateSizes,\n      payload: {\n        direction: e,\n        gutterIdx: t\n      }\n    });\n  }, []),\n        G = n.useCallback((e, t, n) => {\n    D({\n      type: h.CreatePairs,\n      payload: {\n        direction: e,\n        children: t,\n        gutters: n\n      }\n    });\n  }, []),\n        P = n.useCallback((e, t, n, i) => {\n    const r = t[0].parentNode;\n    if (!r) throw new Error(\"Cannot set initial sizes - parent is undefined\");\n    if (void 0 === c(e, r)) throw new Error(\"Cannot set initial sizes - parent has undefined size\");\n    t.forEach((r, a) => {\n      const o = a === t.length - 1;\n      let g;\n\n      if (t.length > 1) {\n        n[o ? a - 1 : a].getBoundingClientRect()[e === p.Horizontal ? \"width\" : \"height\"];\n      }\n\n      g = i && a < i.length ? `calc(${i[a]}% - 0px)` : `calc(${100 / t.length}% - 0px)`, e === p.Horizontal ? (r.style.width = g, r.style.height = \"100%\") : (r.style.height = g, r.style.width = \"100%\");\n    });\n  }, []),\n        T = n.useCallback((e, t) => {\n    if (void 0 === I.draggingIdx) throw new Error(\"Cannot adjust size - 'draggingIdx' is undefined\");\n    const n = I.pairs[I.draggingIdx];\n    if (void 0 === n.size) throw new Error(\"Cannot adjust size - 'pair.size' is undefined\");\n    if (void 0 === n.gutterSize) throw new Error(\"Cannot adjust size - 'pair.gutterSize' is undefined\");\n\n    const i = n.aSizePct + n.bSizePct,\n          r = t / n.size * i,\n          a = i - t / n.size * i,\n          o = 0 === I.draggingIdx,\n          g = I.draggingIdx === I.pairs.length - 1,\n          {\n      aGutterSize: d,\n      bGutterSize: s\n    } = _(n.gutterSize, o, g),\n          c = `calc(${r}% - ${d}px)`,\n          l = `calc(${a}% - ${s}px)`;\n\n    e === p.Horizontal ? (n.a.style.width = c, n.b.style.width = l) : (n.a.style.height = c, n.b.style.height = l);\n  }, [I.draggingIdx, I.pairs, r]),\n        L = n.useCallback((e, t, n) => {\n    if (!I.isDragging) return;\n    if (void 0 === I.draggingIdx) throw new Error(\"Cannot drag - 'draggingIdx' is undefined\");\n    const i = I.pairs[I.draggingIdx];\n    if (void 0 === i.start) throw new Error(\"Cannot drag - 'pair.start' is undefined\");\n    if (void 0 === i.size) throw new Error(\"Cannot drag - 'pair.size' is undefined\");\n    if (void 0 === i.gutterSize) throw new Error(\"Cannot drag - 'pair.gutterSize' is undefined\");\n\n    let r = function (e, t) {\n      return e === p.Horizontal ? t.clientX : t.clientY;\n    }(t, e) - i.start,\n        a = 16,\n        o = 16;\n\n    n.length > I.draggingIdx && (a = n[I.draggingIdx]), n.length >= I.draggingIdx + 1 && (o = n[I.draggingIdx + 1]), r < i.gutterSize + a && (r = i.gutterSize + a), r >= i.size - (i.gutterSize + o) && (r = i.size - (i.gutterSize + o)), T(t, r);\n  }, [I.isDragging, I.draggingIdx, I.pairs, T]);\n\n  function V(e, t) {\n    if (!e.current) throw new Error(\"Can't add element to ref object - ref isn't initialized\");\n    t && !e.current.includes(t) && e.current.push(t);\n  }\n\n  return l(\"mouseup\", () => {\n    if (I.isDragging) {\n      if (void 0 === I.draggingIdx) throw new Error(\"Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined\");\n      F(r, I.draggingIdx), $();\n    }\n  }, [I.isDragging, $]), l(\"mousemove\", e => {\n    I.isDragging && L(e, r, r === p.Horizontal ? a : o);\n  }, [r, I.isDragging, L, a, o]), i(function () {\n    if (!H.current) return;\n    const e = H.current.parentElement;\n    if (!e) return;\n    const t = new ResizeObserver(() => {\n      const t = getComputedStyle(e),\n            n = r === p.Horizontal ? e.clientWidth : e.clientHeight;\n      O(!!t && !!n);\n    });\n    return t.observe(e), () => {\n      t.disconnect();\n    };\n  }, [H.current, r]), i(function () {\n    if (I.isReady) {\n      if (!E.current || !j.current) throw new Error(\"Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined\");\n      B.length <= 1 ? P(r, E.current, j.current, s) : (P(r, E.current, j.current, s), G(r, E.current, j.current));\n    }\n  }, [k, I.isReady, r, P, G, s]), e(\"div\", Object.assign({\n    className: `__dbk__container ${r}`,\n    ref: H\n  }, {\n    children: I.isReady && B.map((i, a) => t(n.Fragment, {\n      children: [e(\"div\", Object.assign({\n        ref: e => V(E, e),\n        className: \"__dbk__child-wrapper \" + (a < v.length ? v[a] : \"\")\n      }, {\n        children: i\n      }), void 0), a < B.length - 1 && e(u, {\n        ref: e => V(j, e),\n        className: S,\n        theme: y,\n        draggerClassName: m,\n        direction: r,\n        onMouseDown: e => function (e, t) {\n          t.preventDefault(), F(r, e), N(r, e);\n        }(a, e)\n      }, void 0)]\n    }, a))\n  }), void 0);\n}\n\nexport { f as GutterTheme, p as SplitDirection, y as default };","map":{"version":3,"mappings":"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","names":["getInnerSize","direction","element","computedStyle","getComputedStyle","size","SplitDirection","Horizontal","clientWidth","clientHeight","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","useEventListener","event","handler","deps","useEffect","window","addEventListener","removeEventListener","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","Gutter","React","forwardRef","className","theme","draggerClassName","Vertical","onMouseDown","containerClass","draggerClass","_jsx","dir","ActionType","GutterTheme","getGutterSizes","gutterSize","isFirst","isLast","aGutterSize","bGutterSize","reducer","state","action","SetIsReadyToCompute","isReady","payload","CreatePairs","children","gutters","parent","parentNode","Error","parentSize","undefined","pairs","forEach","_","idx","a","b","gutter","start","getBoundingClientRect","left","top","end","right","bottom","width","height","pair","aSizePct","length","bSizePct","push","StartDragging","gutterIdx","isDragging","draggingIdx","StopDragging","CalculateSizes","flattenChildren","depth","keys","Children","toArray","reduce","acc","node","nodeIndex","isFragment","apply","props","concat","key","isValidElement","cloneElement","String","join","getCursorIcon","initialState","Split","minWidths","minHeights","initialSizes","gutterTheme","Dark","gutterClassName","reactChildren","onResizeStarted","onResizeFinished","classes","dispatch","useReducer","containerRef","useRef","childRefs","gutterRefs","current","setIsReadyToCompute","useCallback","startDragging","userSelect","cursor","body","stopDragging","allSizes","aSize","calculateSizes","createPairs","setInitialSizes","c","calc","adjustSize","offset","percentage","aCalc","bCalc","drag","e","minSizes","clientX","clientY","getMousePosition","aMinSize","bMinSize","addRef","refs","el","includes","parentElement","observer","ResizeObserver","observe","disconnect","map","_jsxs","Fragment","preventDefault","handleGutterMouseDown"],"sources":["L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\utils\\getInnerSize.ts","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\useEventListener.ts","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\node_modules\\style-inject\\dist\\style-inject.es.js","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\Gutter.tsx","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\state\\reducer.actions.ts","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\index.tsx","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\utils\\getGutterSize.ts","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\state\\reducer.ts","L:\\3rdyearproject\\peacock\\console-application\\node_modules\\@devbookhq\\splitter\\src\\utils\\flattenChildren.ts"],"sourcesContent":["import { SplitDirection } from '../index';\n\nexport default function getInnerSize(direction: SplitDirection, element: HTMLElement) {\n  // Returns undefined if parent element has no layout yet.\n  // Or if the parent has no size.\n\n  const computedStyle = getComputedStyle(element);\n  if (!computedStyle) return;\n\n  let size = direction === SplitDirection.Horizontal ? element.clientWidth : element.clientHeight;\n\n  if (size === 0) return;\n\n  if (direction === SplitDirection.Horizontal) {\n    size -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  } else {\n    size -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  }\n\n  return size;\n}\n","import { useEffect } from 'react';\n\nfunction useEventListener(event: string, handler: (event: any) => void, deps: any[] = []) {\n  useEffect(() => {\n    window.addEventListener(event, handler);\n    return () => window.removeEventListener(event, handler);\n\n// eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [event, handler, ...deps]);\n}\n\nexport default useEventListener;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React from 'react';\nimport { SplitDirection, GutterTheme } from './index';\n\ninterface GutterProps {\n  className?: string;\n  theme: GutterTheme;\n  draggerClassName?: string;\n  direction?: SplitDirection;\n  onMouseDown?: (e: any) => void;\n}\n\nconst Gutter = React.forwardRef<HTMLDivElement, GutterProps>((\n  {\n    className,\n    theme,\n    draggerClassName,\n    direction = SplitDirection.Vertical,\n    onMouseDown,\n  },\n  ref,\n) => {\n  const containerClass = `__dbk__gutter ${direction} ${className || theme}`;\n  const draggerClass = `__dbk__dragger ${direction} ${draggerClassName || theme}`;\n\n  return (\n    <div\n      className={containerClass}\n      ref={ref}\n      dir={direction}\n      onMouseDown={onMouseDown}\n    >\n      <div className={draggerClass}/>\n    </div>\n  );\n});\n\nexport default Gutter;\n\n","import type { SplitDirection } from 'index';\n\nexport enum ActionType {\n  SetIsReadyToCompute,\n  CreatePairs,\n  CalculateSizes,\n  StartDragging,\n  StopDragging,\n}\n\nexport interface SetIsReadyToCompute {\n  type: ActionType.SetIsReadyToCompute;\n  payload: {\n    isReady: boolean,\n  };\n}\n\nexport interface CreatePairs {\n  type: ActionType.CreatePairs;\n  payload: {\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n  };\n}\n\nexport interface CalculateSizes {\n  type: ActionType.CalculateSizes;\n  payload: {\n    direction: SplitDirection,\n    gutterIdx: number;\n  };\n}\n\nexport interface StartDragging {\n  type: ActionType.StartDragging;\n  payload: {\n    gutterIdx: number;\n  };\n}\n\ninterface StopDragging {\n  type: ActionType.StopDragging;\n}\n\nexport type Action = SetIsReadyToCompute\n  | CreatePairs\n  | CalculateSizes\n  | StartDragging\n  | StopDragging;\n\n\n","import React, {\n  useEffect,\n  useReducer,\n  useRef,\n} from 'react';\n\nimport './index.css';\nimport getInnerSize from './utils/getInnerSize';\nimport useEventListener from './useEventListener';\nimport Gutter from './Gutter';\nimport { ActionType } from './state/reducer.actions';\nimport reducer, { State } from './state/reducer';\nimport getGutterSizes from './utils/getGutterSize';\nimport flattenChildren from './utils/flattenChildren';\n\nexport enum SplitDirection {\n  Horizontal = 'Horizontal',\n  Vertical = 'Vertical',\n}\n\nexport enum GutterTheme {\n  Light = 'Light',\n  Dark = 'Dark',\n}\n\nconst DefaultMinSize = 16;\n\nfunction getMousePosition(dir: SplitDirection, e: MouseEvent) {\n  if (dir === SplitDirection.Horizontal) return e.clientX;\n  return e.clientY;\n}\n\nfunction getCursorIcon(dir: SplitDirection) {\n  if (dir === SplitDirection.Horizontal) return 'col-resize';\n  return 'row-resize';\n}\n\n/*\nconst stateInit: State = (direction: SplitDirection = SplitDirection.Horizontal) => ({\n  direction,\n  isDragging: false,\n  pairs: [],\n});\n*/\n\nconst initialState: State = {\n  isReady: false,\n  isDragging: false,\n  pairs: [],\n}\n\ninterface SplitProps {\n  direction?: SplitDirection;\n  minWidths?: number[]; // In pixels.\n  minHeights?: number[]; // In pixels.\n  initialSizes?: number[]; // In percentage.\n  gutterTheme?: GutterTheme;\n  gutterClassName?: string;\n  draggerClassName?: string;\n  children?: React.ReactNode;\n  onResizeStarted?: (pairIdx: number) => void;\n  onResizeFinished?: (pairIdx: number, newSizes: number[]) => void;\n  classes?: string[];\n}\n\nfunction Split({\n  direction = SplitDirection.Horizontal,\n  minWidths = [],\n  minHeights = [],\n  initialSizes,\n  gutterTheme = GutterTheme.Dark,\n  gutterClassName,\n  draggerClassName,\n  children: reactChildren,\n  onResizeStarted,\n  onResizeFinished,\n  classes = [],\n}: SplitProps) {\n  const children = flattenChildren(reactChildren)\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const containerRef = useRef<HTMLDivElement>(null)\n  const childRefs = useRef<HTMLElement[]>([]);\n  const gutterRefs = useRef<HTMLElement[]>([]);\n  // We want to reset refs on each re-render so they don't contain old references.\n  childRefs.current = [];\n  gutterRefs.current = [];\n\n  // Helper dispatch functions.\n  const setIsReadyToCompute = React.useCallback((isReady: boolean) => {\n    dispatch({\n      type: ActionType.SetIsReadyToCompute,\n      payload: { isReady },\n    })\n  }, [])\n\n  const startDragging = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.StartDragging,\n      payload: { gutterIdx },\n    });\n\n    const pair = state.pairs[gutterIdx];\n    onResizeStarted?.(pair.idx)\n\n    // Disable selection.\n    pair.a.style.userSelect = 'none';\n    pair.b.style.userSelect = 'none';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, nut just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = getCursorIcon(direction);\n    pair.parent.style.cursor = getCursorIcon(direction);\n    document.body.style.cursor = getCursorIcon(direction);\n  }, [state.pairs]);\n\n  const stopDragging = React.useCallback(() => {\n    dispatch({\n      type: ActionType.StopDragging,\n    });\n\n    // The callback receives an index of the resized pair and new sizes of all child elements.\n    const allSizes: number[] = [];\n    for (let idx = 0; idx < state.pairs.length; idx++) {\n      const pair = state.pairs[idx];\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (parentSize === undefined) throw new Error(`Cannot call the 'onResizeFinished' callback - parentSize is undefined`);\n      if (pair.gutterSize === undefined) throw new Error(`Cannot call 'onResizeFinished' callback - gutterSize is undefined`);\n\n      const isFirst = idx === 0;\n      const isLast = idx === state.pairs.length - 1;\n\n      const aSize = pair.a.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n      const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n      const aSizePct = ((aSize + aGutterSize) / parentSize) * 100;\n      allSizes.push(aSizePct);\n\n      if (isLast) {\n        const bSize = pair.b.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        const bSizePct = ((bSize + bGutterSize) / parentSize) * 100;\n        allSizes.push(bSizePct);\n      }\n    }\n\n    if (state.draggingIdx === undefined) throw new Error(`Could not reset cursor and user-select because 'state.draggingIdx' is undefined`);\n    const pair = state.pairs[state.draggingIdx];\n    onResizeFinished?.(pair.idx, allSizes);\n\n    // Disable selection.\n    pair.a.style.userSelect = '';\n    pair.b.style.userSelect = '';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, not just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = '';\n    pair.parent.style.cursor = '';\n    document.body.style.cursor = '';\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const calculateSizes = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.CalculateSizes,\n      payload: { direction, gutterIdx },\n    });\n  }, []);\n\n  const createPairs = React.useCallback((direction: SplitDirection, children: HTMLElement[], gutters: HTMLElement[]) => {\n    dispatch({\n      type: ActionType.CreatePairs,\n      payload: { direction, children, gutters },\n    });\n  }, []);\n  /////////\n\n  // This method is called on the initial render.\n  // It iterates through the all children sets their initial sizes.\n  const setInitialSizes = React.useCallback((\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n    initialSizes?: number[],\n  ) => {\n    // All children must have common parent.\n    const parent = children[0].parentNode;\n    if (!parent) throw new Error(`Cannot set initial sizes - parent is undefined`);\n    const parentSize = getInnerSize(direction, parent as HTMLElement);\n    if (parentSize === undefined) throw new Error(`Cannot set initial sizes - parent has undefined size`);\n\n    children.forEach((c, idx) => {\n      const isFirst = idx === 0;\n      const isLast = idx === children.length - 1;\n\n      let gutterSize = 0\n      if (children.length > 1) {\n        const gutter = gutters[isLast ? idx-1 : idx];\n        let gutterSize = gutter.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        gutterSize = isFirst || isLast ? gutterSize / 2 : gutterSize;\n      }\n\n      let calc: string;\n      if (initialSizes && idx < initialSizes.length)  {\n        calc = `calc(${initialSizes[idx]}% - ${gutterSize}px)`;\n      } else {\n        // '100 / children.length' makes all the children same wide.\n        calc = `calc(${100 / children.length}% - ${gutterSize}px)`;\n      }\n\n      if (direction === SplitDirection.Horizontal) {\n        c.style.width = calc;\n        // Reset the child wrapper's height because the direction could have changed.\n        c.style.height = '100%';\n      } else {\n        c.style.height = calc;\n        // Reset the child wrapper's width because the direction could have changed.\n        c.style.width = '100%';\n      }\n    });\n  }, []);\n\n  // Here we actually change the width of children.\n  // We convert the element's sizes into percentage\n  // and let the CSS 'calc' function do the heavy lifting.\n  // Size of 'pair.a' is same as 'offset'.\n  //\n  // For just 2 children total, the percentage adds up always to 100.\n  // For >2 children total, the percentage adds to less than 100.\n  // That's because a single gutter changes sizes of only the given pair of children.\n  // Each gutter changes size only of the two adjacent elements.\n  // -----------------------------------------------------------------------\n  // |                     |||                     |||                     |\n  // |       33.3%         |||        33.3%        |||       33.3%         |\n  // |                     |||                     |||                     |\n  // |                     |||                     |||                     |\n  // -----------------------------------------------------------------------\n  const adjustSize = React.useCallback((direction: SplitDirection, offset: number) => {\n    if (state.draggingIdx === undefined) throw new Error(`Cannot adjust size - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.size === undefined) throw new Error(`Cannot adjust size - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot adjust size - 'pair.gutterSize' is undefined`);\n    const percentage = pair.aSizePct + pair.bSizePct;\n\n    const aSizePct = (offset / pair.size) * percentage;\n    const bSizePct = percentage - (offset / pair.size) * percentage;\n\n    const isFirst = state.draggingIdx === 0;\n    const isLast = state.draggingIdx === state.pairs.length - 1;\n    const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n\n    const aCalc = `calc(${aSizePct}% - ${aGutterSize}px)`;\n    const bCalc = `calc(${bSizePct}% - ${bGutterSize}px)`;\n    if (direction === SplitDirection.Horizontal) {\n      pair.a.style.width = aCalc;\n      pair.b.style.width = bCalc;\n    } else {\n      pair.a.style.height = aCalc;\n      pair.b.style.height = bCalc;\n    }\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const drag = React.useCallback((e: MouseEvent, direction: SplitDirection, minSizes: number[]) => {\n    if (!state.isDragging) return\n    if (state.draggingIdx === undefined) throw new Error(`Cannot drag - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.start === undefined) throw new Error(`Cannot drag - 'pair.start' is undefined`);\n    if (pair.size === undefined) throw new Error(`Cannot drag - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot drag - 'pair.gutterSize' is undefined`);\n\n    // 'offset' is the width of the 'a' element in a pair.\n    let offset = getMousePosition(direction, e) - pair.start;\n\n    // Limit the maximum size and the minimum size of resized children.\n\n    let aMinSize = DefaultMinSize;\n    let bMinSize = DefaultMinSize;\n    if (minSizes.length > state.draggingIdx) {\n      aMinSize = minSizes[state.draggingIdx];\n    }\n    if (minSizes.length >= state.draggingIdx + 1) {\n      bMinSize = minSizes[state.draggingIdx + 1];\n    }\n\n    // TODO: We should check whether the parent is big enough\n    // to support these min sizes.\n    if (offset < pair.gutterSize + aMinSize) {\n      offset = pair.gutterSize + aMinSize;\n    }\n\n    if (offset >= pair.size - (pair.gutterSize + bMinSize)) {\n      offset = pair.size - (pair.gutterSize + bMinSize);\n    }\n\n    adjustSize(direction, offset);\n  }, [state.isDragging, state.draggingIdx, state.pairs, adjustSize]);\n\n  function handleGutterMouseDown(gutterIdx: number, e: MouseEvent) {\n    e.preventDefault();\n    calculateSizes(direction, gutterIdx);\n    startDragging(direction, gutterIdx);\n  }\n\n  useEventListener('mouseup', () => {\n    if (!state.isDragging) return;\n    if (state.draggingIdx === undefined)\n      throw new Error(`Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined`);\n    calculateSizes(direction, state.draggingIdx);\n    stopDragging();\n  }, [state.isDragging, stopDragging]);\n\n  useEventListener('mousemove', (e: MouseEvent) => {\n    if (!state.isDragging) return;\n    drag(e, direction, direction === SplitDirection.Horizontal ? minWidths : minHeights);\n  }, [direction, state.isDragging, drag, minWidths, minHeights]);\n\n  // This makes sure that Splitter properly re-renders if parent's size changes dynamically.\n  useEffect(function watchParentSize() {\n    if (!containerRef.current) return\n    const el = containerRef.current.parentElement\n\n    // Splitter must have a parent element. In the most trivial example it's either <body> or <html>.\n    if (!el) return\n\n    // TODO: Potential performance issue!\n    // When nesting Splitters the `observer` is registered for each nesting \"level\".\n    // Splitter's parent element is another Splitter in the nesting use case.\n    const observer = new ResizeObserver(() => {\n      const style = getComputedStyle(el)\n      const size = direction === SplitDirection.Horizontal ? el.clientWidth : el.clientHeight\n      const isReady = !!style && !!size\n      setIsReadyToCompute(isReady)\n    })\n    observer.observe(el)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [\n    containerRef.current,\n    direction,\n  ])\n\n  // Initial setup, runs every time the child views change.\n  useEffect(function initialSetup() {\n    if (!state.isReady) return\n    // By the time first useEffect runs refs should be already set, unless something really bad happened.\n    if (!childRefs.current || !gutterRefs.current) {\n      throw new Error(`Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined`);\n    }\n\n    // Don't create pairs if there's only one child.\n    if (children.length <= 1) {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n    } else {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n      createPairs(direction, childRefs.current, gutterRefs.current);\n    }\n\n  }, [\n    reactChildren,\n    state.isReady,\n    direction,\n    setInitialSizes,\n    createPairs,\n    initialSizes,\n  ]);\n\n  function addRef(refs: typeof childRefs | typeof gutterRefs, el: any) {\n    if (!refs.current) throw new Error(`Can't add element to ref object - ref isn't initialized`);\n    if (el && !refs.current.includes(el)) {\n      refs.current.push(el);\n    }\n  }\n\n  return (\n    <div\n      className={'__dbk__container ' + `${direction}`}\n      ref={containerRef}\n    >\n      {state.isReady && children.map((c, idx) => (\n        <React.Fragment key={idx}>\n          <div\n            ref={el => addRef(childRefs, el)}\n            className={'__dbk__child-wrapper ' + (idx < classes.length ? classes[idx] : '')}\n          >{c}\n          </div>\n\n          {/* Gutter is between each two child views. */}\n          {idx < (children as React.ReactNodeArray).length - 1 &&\n            <Gutter\n              ref={el => addRef(gutterRefs, el)}\n              className={gutterClassName}\n              theme={gutterTheme}\n              draggerClassName={draggerClassName}\n              direction={direction}\n              onMouseDown={e => handleGutterMouseDown(idx, e)}\n            />\n          }\n        </React.Fragment>\n      ))}\n    </div>\n  );\n}\n\nexport type {\n  SplitProps\n}\nexport default Split;\n","export default function getGutterSizes(gutterSize: number, isFirst: boolean, isLast: boolean) {\n  let aGutterSize: number;\n  let bGutterSize: number;\n\n  if (isFirst) {\n    aGutterSize = gutterSize / 2;\n    bGutterSize = gutterSize;\n  } else if (isLast) {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize / 2;\n  } else {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize;\n  }\n\n  return { aGutterSize, bGutterSize };\n};\n","import { SplitDirection } from '../index';\nimport { Action, ActionType } from './reducer.actions';\nimport Pair from '../pair';\n\nimport getInnerSize from '../utils/getInnerSize';\nimport getGutterSizes from '../utils/getGutterSize';\n\nexport interface State {\n  isReady: boolean;\n\n  isDragging: boolean;\n  draggingIdx?: number; // Index of a gutter that is being dragged.\n\n  pairs: Pair[];\n}\n\nexport default function reducer(state: State, action: Action) {\n  switch (action.type) {\n    case ActionType.SetIsReadyToCompute: {\n      return {\n        ...state,\n        isReady: action.payload.isReady,\n      }\n    }\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    case ActionType.CreatePairs: {\n      const { direction, children, gutters } = action.payload;\n\n      // All children must have common parent.\n      const parent = children[0].parentNode;\n      if (!parent) throw new Error(`Cannot create pairs - parent is undefined.`);\n      const parentSize = getInnerSize(direction, parent as HTMLElement);\n      if (parentSize === undefined) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${parentSize}.`);\n\n      const pairs: Pair[] = [];\n      children.forEach((_, idx) => {\n        if (idx > 0) {\n          const a = children[idx-1];\n          const b = children[idx];\n          const gutter = gutters[idx-1];\n\n          const start = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().left\n            : a.getBoundingClientRect().top;\n\n          const end = direction === SplitDirection.Horizontal\n            ? b.getBoundingClientRect().right\n            : b.getBoundingClientRect().bottom;\n\n          const size = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().width + gutter.getBoundingClientRect().width + b.getBoundingClientRect().width\n            : a.getBoundingClientRect().height + gutter.getBoundingClientRect().height + b.getBoundingClientRect().height\n\n          const gutterSize = direction === SplitDirection.Horizontal\n            ? gutter.getBoundingClientRect().width\n            : gutter.getBoundingClientRect().height;\n\n          const pair: Pair = {\n            idx: idx-1,\n            // TODO: Do we need to have a reference to the whole elements? Aren't indexes enough?\n            a,\n            b,\n            gutter,\n            parent: parent as HTMLElement,\n            start,\n            end,\n            size,\n            gutterSize,\n            // At the start, all elements has the same width.\n            aSizePct: 100 / children.length,\n            bSizePct: 100 / children.length,\n          };\n\n          pairs.push(pair);\n        }\n      });\n\n      return {\n        ...state,\n        pairs,\n      };\n    }\n    case ActionType.StartDragging: {\n      const { gutterIdx } = action.payload;\n      return {\n        ...state,\n        isDragging: true,\n        draggingIdx: gutterIdx,\n      };\n    }\n    case ActionType.StopDragging: {\n      return {\n        ...state,\n        isDragging: false,\n      };\n    }\n    // Recalculates the stored sizes based on the actual elements' sizes.\n    case ActionType.CalculateSizes: {\n      // We need to calculate sizes only for the pair\n      // that has the moved gutter.\n      const { direction, gutterIdx } = action.payload;\n      const pair = state.pairs[gutterIdx];\n\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (!parentSize) throw new Error(`Cannot calculate sizes - 'pair.parent' has undefined or zero size.`);\n\n      const gutterSize = pair.gutter[direction === SplitDirection.Horizontal ? 'clientWidth' : 'clientHeight'];\n\n      const isFirst = gutterIdx === 0;\n      const isLast = gutterIdx === state.pairs.length - 1;\n      const { aGutterSize, bGutterSize } = getGutterSizes(gutterSize, isFirst, isLast);\n\n      let start: number;\n      let end: number;\n      let size: number;\n      let aSizePct: number;\n      let bSizePct: number;\n\n      if (direction === SplitDirection.Horizontal) {\n        start = pair.a.getBoundingClientRect().left;\n\n        end = pair.b.getBoundingClientRect().right;\n\n        aSizePct = ((pair.a.getBoundingClientRect().width + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().width + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().width +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().width;\n      } else {\n        start = pair.a.getBoundingClientRect().top;\n\n        end = pair.b.getBoundingClientRect().bottom;\n\n        aSizePct = ((pair.a.getBoundingClientRect().height + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().height + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().height +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().height;\n      }\n\n      state.pairs[gutterIdx] = {\n        ...pair,\n        start,\n        end,\n        size,\n        aSizePct,\n        bSizePct,\n        gutterSize,\n      };\n\n      return {\n        ...state\n      };\n    }\n    default:\n      return state;\n  }\n}\n\n","// Taken from https://github.com/grrowl/react-keyed-flatten-children\n\n/* Returns React children into an array, flattening fragments. */\nimport {\n  ReactNode,\n  ReactChild,\n  Children,\n  isValidElement,\n  cloneElement\n} from 'react';\nimport { isFragment } from 'react-is';\n\nexport default function flattenChildren(\n  children: ReactNode,\n  depth: number = 0,\n  keys: (string | number)[] = []\n): ReactChild[] {\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) => {\n      if (isFragment(node)) {\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (typeof node === 'string' || typeof node === 'number') {\n          acc.push(node);\n        }\n      }\n      return acc;\n    },\n    []\n  );\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}